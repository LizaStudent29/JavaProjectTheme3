# Сравнение производительности stream() и parallelStream() в Java

## Описание проекта

Данный проект представляет собой учебное приложение для сравнения производительности последовательных (`stream()`) и параллельных (`parallelStream()`) потоков в Java при обработке больших объемов данных.

## Цель проекта

- Практическое изучение различий между параллелизмом и параллельностью
- Измерение производительности последовательной и параллельной обработки данных
- Анализ эффективности использования многопоточности в различных сценариях

## Функциональность

- Генерация списка из 1,000,000 случайных чисел
- Выполнение цепочки операций над данными:
  - **Фильтрация**: отбор только четных чисел
  - **Преобразование**: умножение каждого элемента на 2
  - **Агрегация**: вычисление суммы всех элементов
- Измерение времени выполнения для обоих подходов
- Сравнительный анализ результатов

## Технологии

- Java 8+
- Stream API
- ForkJoinPool (для parallelStream)
- Collections Framework

## Запуск проекта

1. Клонируйте репозиторий:
```bash
git clone <repository-url>
cd stream-comparison
```

2. Скомпилируйте и запустите:
```bash
javac StreamComparison.java
java StreamComparison
```

Или откройте проект в IntelliJ IDEA и запустите класс `StreamComparison`.

## Пример вывода

```
Сравнение производительности stream() vs parallelStream()
Размер списка: 1000000 элементов

=== ПОСЛЕДОВАТЕЛЬНЫЙ ПОТОК (stream()) ===
Результат: 499284200
Время выполнения: 45 мс

=== ПАРАЛЛЕЛЬНЫЙ ПОТОК (parallelStream()) ===
Результат: 499284200
Время выполнения: 28 мс

=== АНАЛИЗ РЕЗУЛЬТАТОВ ===
Последовательный поток: 45 мс
Параллельный поток: 28 мс
Разница: 17 мс
Параллельный поток быстрее в 1.61 раз
```

## Ключевые особенности реализации

- Использование `Stream API` для функциональной обработки данных
- Автоматическое распараллеливание с помощью `parallelStream()`
- Точное измерение времени выполнения с помощью `System.currentTimeMillis()`
- Генерация случайных данных для тестирования

## Результаты и выводы

### Когда использовать parallelStream():
- Большие объемы данных (>100,000 элементов)
- Вычислительно сложные операции
- Многоядерные процессоры
- Операции без состояния

### Когда использовать stream():
- Малые объемы данных
- Простые операции
- Последовательные зависимости
- Минимизация накладных расходов

## Примечания по производительности

- Эффективность parallelStream() зависит от количества ядер процессора
- Накладные расходы на создание потоков могут нивелировать выгоду для маленьких коллекций
- Для оптимальной производительности рекомендуется тестировать оба подхода на конкретных данных
